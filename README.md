# Racketry

Exercises and projects in computer science using Racket.

## SICP Revisited

I have added some Racket style to the SICP
exercises: the use of structs where
convenient, the use of named-let, unit testing,
modules and other Racket features whenever 
they make the code look better and do not defeat 
the purpose of the exercise. I also take opportunities
to practice using multiple return values, Racket for-loops, 
continuations, macros, structs, Racket OOP,
and other language features or styles of programming.

Some SICP examples in the text of the book are refactored 
in various ways that I found interesting or 
enlightening. Procedures are given longer, more
descriptive names. Interesting problems provide opportunities for
going on tangents: there are many such opportunities in SICP.

* **SICP 1.1 -- 1.2.** Exercises 1.1 to 1.28. Expressions. 
Evaluation models: normal order, applicative order. 
Roots, Newton's methond, adaptive methods. Factorials, 
recursion, the Ackermann function, binomials, fibonacci numbers. 
Estimating growth of computations, change-making problems, sin(x). 
Tail-recursion, fast exponentiation, advanced ways of computing 
Fibonacci numbers. gcds, Lame's theorem. The Miller-Rabin prime
test.

* **SICP 1.3.** Exercises 1.29 to 1.37. Lambdas, half-interval
bisection method, fixed-points, average-damping, continued fractions.


## Projects

* Pretty-printing tables.

* Investigation of Lambda-calculus (based on an exercise in SICP.) 

* Generating Sierpinski's triangle with Racket graphics.




