# Racketry

Exercises and projects in computer science using Racket.

## SICP Revisited

I have added some Racket style to the SICP
exercises: the use of structs where
convenient, the use of named-let, unit testing,
modules and other Racket features whenever 
they make the code look better and do not defeat 
the purpose of the exercise. I also take opportunities
to practice using multiple return values, point-free-style code,
Racket for-loops, continuations, macros, struct generics,
and other language features or styles of programming.

Some SICP examples in the text of the book are refactored 
in various ways that I found interesting or 
enlightening. Procedures are given longer, more
descriptive names. Interesting problems provide opportunities for
going on tangents: there are many of those in SICP.

* **SICP 1.1 -- 1.2.** Exercises 1.1 to 1.20. Expressions. 
Evaluation models: normal order, applicative order. 
Roots, Newton's methond, adaptive methods. Factorials, 
recursion, the Ackermann function, binomials, fibonacci numbers. 
Estimating growth of computations, change-making problems, sin(x). 
Tail-recursion, exponentiation, advanced ways of computing 
Fibonacci numbers. Gcds, Lame's theorem.



## Projects

* Investigation of Lambda-calculus (based on an exercise in SICP.) 

* Generating Sierpinski's triangle with Racket graphics.




